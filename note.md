## 功能记录

- 对某个特定的接口进行 mock 数据处理 mock.server.js 中多出一个配置项:`mockData{[{'/xxx':{data:{}}}]}`
- 对某个特定的接口进行格式处理 即中间层意义
- 设置 timeout 超时，超过 timeout 时返回假数据或者之前保存的真实接口数据，这取决于你是 1.纯 mock / 2.有后台接口

- 1. 纯 mock：
- 按照既定的数据结构，自动创建接口，返回对应数据
- 2. 有后台接口 只是接口速度比较慢 或者服务器不稳定
- 模式一：首次请求真实接口 拿到真实接口数据，之后每次前端请求都会重新请求真实的接口地址，拿到数据返回给前端。无任何保存数据的动作
  > 该模式就是正常请求后台接口无 mock 模式
- 模式二：首次请求真实接口 拿到真实接口数据 将其保存一份(fs.writeFile) 并返回给前端；之后该接口的每次请求 会先请求真实接口 如果超过设置的 timeout(需要在 mock.server.js 中配置该 timeout) 即会返回之前保存的请求真实接口的数据
  > 该模式依赖 mock.server.js 中配置的 timeout
  > 如果首次真实接口请求失败 会返回 mock.server.js 中配置的假数据，如果没有配置假数据，则报错
- 模式三：首次请求真实接口 拿到真实接口数据 将其保存一份(fs.writeFile) 并返回给前端；之后该接口的每次请求 都会返回第一次请求真实接口保存的数据
  > 该模式下 如果首次接口比较慢 或直接 down 掉 那么就无法获得数据
  > 如果超时 可以提醒用户写模拟数据
  > 如果首次真实接口请求失败 会返回 mock.server.js 中配置的假数据，如果没有配置假数据，则报错
- 模式四：首次不需要请求接口，直接返回在 mock.server.js 中配置的假数据 mockData 但是它会在后台等待真实接口返回的结果，如果请求到真实数据，就立马保存下来() 那么在下次请求时 就会返回真实的接口数据
  > 该模式依赖 mock.server.js 中配置的假数据，如果没有假数据 应报错

## 相关配置项

- mode 模式
  > just-mock 只 mock 不请求真实接口
  > request 只请求真实接口 不 mock 😄
  > request-timeout 首次请求真实接口，第一次不检测 timeout，之后的请求才根据 timeout 是否超时 来决定返回真实接口数据/首次请求保存的数据/假数据 <首次请求真实接口如果失败就返回 其他数据(备份数据/假数据)>
  > request-timeout-all 首次请求真实接口，第一次检测 timeout，之后的请求也根据 timeout 是否超时 来决定返回真实接口数据/首次请求保存的数据/假数据 <首次请求真实接口如果失败就返回 其他数据(备份数据/假数据)>
  > request-once 首次请求真实接口 之后的请求返回首次请求保存的数据/假数据 <首次请求真实接口如果失败就返回失败 不返回假数据>
  > request-wait 首次不请求真实接口 直接返回假数据 但是它会在后台默认等待真实接口返回数据，如果有真实数据 下次请求就会返回真实数据 <依赖配置的假数据>
- mockServer mock 服务配置相关
  > port 配置本地 mock 服务的端口
  > proxy 配置真实接口的代理地址
  > timeout 真实接口超时时间
- mockData 模拟数据配置相关
  - format 数据外层嵌套结构<可选>
  - apiList 模拟接口列表
    > path 请求路径
    > method 请求方法
    > data 返回数据 <有 format 情况下会被 format 嵌套包裹，否则直接返回 data>

## 数据优先级

- 真实数据 > 备份数据 > mock 数据
  > api > backup > mock

## 接下来要做？

- 将首次请求的数据保存起来 下次请求如果超时 直接返回首次请求保存的数据 ✅
- 添加数据标识位 用来标识当前的数据来自于 真实接口数据/备份数据/假数据 ✅
- 配置文件中添加响应体的包裹{code:0,message:'OK',data:[]} ✅
- 如果没有找到该真实接口，就去找 mock 数据中的 path ✅
- 提供一个清空备份数据的方式
- 提供配置项 是否支持跨域 / 部分跨域 / 全部跨域
- 对外暴露 api 接口
- 提供插入数据方式
- 提供连接远程数据库
